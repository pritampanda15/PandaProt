from typing import Dict, List, Any, Optional
import py3Dmol
from Bio.PDB import Structure
import numpy as np
import os
import tempfile
import base64
from Bio.PDB import PDBParser, PDBIO
from Bio.PDB import Selection
import os
import base64
import tempfile
import numpy as np
from Bio.PDB import PDBIO, PDBParser, Structure
import logging as logger


def export_visualization_scripts(self, output_prefix: str, 
                                interaction_types: Optional[List[str]] = None):
    """
    Export interaction visualization scripts for various molecular viewers.
    
    Args:
        output_prefix: Prefix for output files (without extension)
        interaction_types: Types of interactions to include in visualizations
    
    Returns:
        Dictionary mapping program names to generated filenames
    """
    if not self.structure or not self.interactions:
        print("No structure or interactions to visualize. Run map_interactions() first.")
        return {}
    
    # Filter interactions if needed
    if interaction_types:
        filtered_interactions = {
            k: v for k, v in self.interactions.items() if k in interaction_types
        }
    else:
        filtered_interactions = self.interactions
    
    # Define output files
    output_files = {}
    
    # Create PDB file for reference (needed by all visualization programs)
    pdb_file = f"{output_prefix}.pdb"
    
    # Export PDB if needed
    if not os.path.exists(pdb_file):
        io = PDBIO()
        io.set_structure(self.structure)
        io.save(pdb_file)
        logger.info(f"Saved structure to {pdb_file}")
    
    # Export PyMOL script
    pymol_file = f"{output_prefix}.pml"
    self._export_pymol_script(pymol_file, pdb_file, filtered_interactions)
    output_files["PyMOL"] = pymol_file
    
    # Export Chimera script
    chimera_file = f"{output_prefix}.cmd"
    self._export_chimera_script(chimera_file, pdb_file, filtered_interactions)
    output_files["Chimera"] = chimera_file
    
    # Export VMD script
    vmd_file = f"{output_prefix}.tcl"
    self._export_vmd_script(vmd_file, pdb_file, filtered_interactions)
    output_files["VMD"] = vmd_file
    
    # Export Molstar state file (.molj)
    molstar_file = f"{output_prefix}_molstar.js"
    self._export_molstar_script(molstar_file, pdb_file, filtered_interactions)
    output_files["Molstar"] = molstar_file
    
    logger.info(f"Exported visualization scripts: {', '.join(output_files.values())}")
    return output_files

def _export_pymol_script(self, output_file: str, pdb_file: str, 
                       interactions: Dict[str, List[Dict]]):
    """Generate PyMOL script (.pml) to visualize interactions."""
    # Define colors for different interaction types
    interaction_colors = {
        'hydrogen_bonds': 'blue',
        'ionic_interactions': 'red',
        'salt_bridges': 'yellow',
        'hydrophobic_interactions': 'orange',
        'pi_stacking': 'purple',
        'pi_cation': 'green',
        'disulfide': 'gold'
    }
    
    with open(output_file, 'w') as f:
        # Header and load structure
        f.write(f"# PyMOL script for visualizing protein interactions\n")
        f.write(f"# Generated by PandaProt\n\n")
        
        # Load the PDB structure
        rel_path = os.path.relpath(pdb_file, os.path.dirname(output_file))
        f.write(f"load {rel_path}, protein\n")
        
        # Set up initial view
        f.write("hide everything\n")
        f.write("show cartoon\n")
        f.write("color gray80, protein\n")
        f.write("set cartoon_transparency, 0.5\n\n")
        
        # Setup groups for organization
        f.write("group Interactions\n")
        
        # Process each interaction type
        for interaction_type, interactions_list in interactions.items():
            if not interactions_list:
                continue
                
            color = interaction_colors.get(interaction_type, "gray50")
            pymol_name = interaction_type.replace("_", "")
            
            # Create a group for this interaction type
            f.write(f"group {pymol_name}, {pymol_name}_*\n")
            
            # Process each interaction
            for i, interaction in enumerate(interactions_list, 1):
                try:
                    # Extract residue info based on interaction type
                    if interaction_type == 'hydrogen_bonds':
                        chain1 = interaction.get('donor_chain')
                        res1 = interaction.get('donor_residue').split()[-1] if ' ' in interaction.get('donor_residue', '') else interaction.get('donor_residue', '')
                        atom1 = interaction.get('donor_atom')
                        
                        chain2 = interaction.get('acceptor_chain')
                        res2 = interaction.get('acceptor_residue').split()[-1] if ' ' in interaction.get('acceptor_residue', '') else interaction.get('acceptor_residue', '')
                        atom2 = interaction.get('acceptor_atom')
                        
                        # Skip if missing data
                        if not all([chain1, res1, atom1, chain2, res2, atom2]):
                            continue
                            
                        sel1 = f"chain {chain1} and resi {res1} and name {atom1}"
                        sel2 = f"chain {chain2} and resi {res2} and name {atom2}"
                        
                    elif interaction_type in ['ionic_interactions', 'salt_bridges']:
                        if all(k in interaction for k in ['positive_residue', 'positive_chain']):
                            chain1 = interaction.get('positive_chain')
                            res1 = interaction.get('positive_residue').split()[-1] if ' ' in interaction.get('positive_residue', '') else interaction.get('positive_residue', '')
                            atom1 = interaction.get('positive_atom', '*')
                            
                            chain2 = interaction.get('negative_chain')
                            res2 = interaction.get('negative_residue').split()[-1] if ' ' in interaction.get('negative_residue', '') else interaction.get('negative_residue', '')
                            atom2 = interaction.get('negative_atom', '*')
                        else:
                            # Fallback to generic naming
                            chain1 = interaction.get('chain1')
                            res1 = interaction.get('residue1').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                            atom1 = interaction.get('atom1', '*')
                            
                            chain2 = interaction.get('chain2')
                            res2 = interaction.get('residue2').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                            atom2 = interaction.get('atom2', '*')
                            
                        # Skip if missing data
                        if not all([chain1, res1, chain2, res2]):
                            continue
                            
                        sel1 = f"chain {chain1} and resi {res1}"
                        if atom1 != '*':
                            sel1 += f" and name {atom1}"
                            
                        sel2 = f"chain {chain2} and resi {res2}"
                        if atom2 != '*':
                            sel2 += f" and name {atom2}"
                    
                    else:
                        # Generic handling for other interaction types
                        chain1 = interaction.get('chain1', interaction.get('residue1_chain'))
                        res1 = interaction.get('residue1', '').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                        
                        chain2 = interaction.get('chain2', interaction.get('residue2_chain'))
                        res2 = interaction.get('residue2', '').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                        
                        # Skip if missing data
                        if not all([chain1, res1, chain2, res2]):
                            continue
                            
                        sel1 = f"chain {chain1} and resi {res1}"
                        sel2 = f"chain {chain2} and resi {res2}"
                    
                    # Create a unique object name for this interaction
                    obj_name = f"{pymol_name}_{i:03d}"
                    
                    # Create PyMOL distance object
                    f.write(f"distance {obj_name}, ({sel1}), ({sel2})\n")
                    f.write(f"color {color}, {obj_name}\n")
                    
                    # Show relevant residues
                    f.write(f"show sticks, ({sel1}) or ({sel2})\n")
                
                except Exception as e:
                    logger.warning(f"Error processing interaction for PyMOL: {e}")
                    continue
            
            # Set properties for this interaction type
            f.write(f"set dash_gap, 0.3, {pymol_name}_*\n")
            f.write(f"set dash_width, 2.0, {pymol_name}_*\n")
            f.write(f"set dash_radius, 0.1, {pymol_name}_*\n\n")
        
        # Final view settings
        f.write("# Final view settings\n")
        f.write("zoom\n")
        f.write("set ray_shadows, 0\n")
        f.write("set depth_cue, 1\n")
        f.write("set valence, 0\n")
        f.write("bg_color white\n\n")
        
        # Add a legend
        f.write("# Create legend\n")
        f.write("set label_color, black\n")
        y_pos = 0
        for interaction_type, color in interaction_colors.items():
            if interaction_type in interactions and interactions[interaction_type]:
                nice_name = interaction_type.replace('_', ' ').title()
                f.write(f"pseudoatom leg_{interaction_type}, pos=[10, {y_pos}, 0]\n")
                f.write(f"color {color}, leg_{interaction_type}\n")
                f.write(f"label leg_{interaction_type}, \"{nice_name}\"\n")
                y_pos -= 2
        
        logger.info(f"Saved PyMOL script to {output_file}")

def _export_chimera_script(self, output_file: str, pdb_file: str, 
                         interactions: Dict[str, List[Dict]]):
    """Generate UCSF Chimera script (.cmd) to visualize interactions."""
    # Define colors for different interaction types
    interaction_colors = {
        'hydrogen_bonds': '0,0,255',  # blue
        'ionic_interactions': '255,0,0',  # red
        'salt_bridges': '255,255,0',  # yellow
        'hydrophobic_interactions': '255,165,0',  # orange
        'pi_stacking': '128,0,128',  # purple
        'pi_cation': '0,128,0',  # green
        'disulfide': '218,165,32'  # gold
    }
    
    with open(output_file, 'w') as f:
        # Header
        f.write("# UCSF Chimera script for visualizing protein interactions\n")
        f.write("# Generated by PandaProt\n\n")
        
        # Open the PDB file
        rel_path = os.path.relpath(pdb_file, os.path.dirname(output_file))
        f.write(f"open {rel_path}\n")
        
        # Initial display settings
        f.write("~display\n")  # hide everything
        f.write("cartoon\n")   # show cartoons
        f.write("color gray cartoon\n")  # color cartoons gray
        f.write("transparency 50 cartoon\n\n")  # make cartoons transparent
        
        # Process each interaction
        for interaction_type, interactions_list in interactions.items():
            if not interactions_list:
                continue
                
            color = interaction_colors.get(interaction_type, "128,128,128")  # default gray
            
            f.write(f"# {interaction_type.replace('_', ' ').title()}\n")
            
            for i, interaction in enumerate(interactions_list):
                try:
                    # Extract residue info based on interaction type
                    if interaction_type == 'hydrogen_bonds':
                        chain1 = interaction.get('donor_chain')
                        res1 = interaction.get('donor_residue').split()[-1] if ' ' in interaction.get('donor_residue', '') else interaction.get('donor_residue', '')
                        atom1 = interaction.get('donor_atom')
                        
                        chain2 = interaction.get('acceptor_chain')
                        res2 = interaction.get('acceptor_residue').split()[-1] if ' ' in interaction.get('acceptor_residue', '') else interaction.get('acceptor_residue', '')
                        atom2 = interaction.get('acceptor_atom')
                        
                        # Skip if missing data
                        if not all([chain1, res1, atom1, chain2, res2, atom2]):
                            continue
                            
                        sel1 = f"#{chain1}:{res1}@{atom1}"
                        sel2 = f"#{chain2}:{res2}@{atom2}"
                        
                    elif interaction_type in ['ionic_interactions', 'salt_bridges']:
                        if all(k in interaction for k in ['positive_residue', 'positive_chain']):
                            chain1 = interaction.get('positive_chain')
                            res1 = interaction.get('positive_residue').split()[-1] if ' ' in interaction.get('positive_residue', '') else interaction.get('positive_residue', '')
                            atom1 = interaction.get('positive_atom', '')
                            
                            chain2 = interaction.get('negative_chain')
                            res2 = interaction.get('negative_residue').split()[-1] if ' ' in interaction.get('negative_residue', '') else interaction.get('negative_residue', '')
                            atom2 = interaction.get('negative_atom', '')
                        else:
                            # Fallback to generic naming
                            chain1 = interaction.get('chain1')
                            res1 = interaction.get('residue1').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                            atom1 = interaction.get('atom1', '')
                            
                            chain2 = interaction.get('chain2')
                            res2 = interaction.get('residue2').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                            atom2 = interaction.get('atom2', '')
                            
                        # Skip if missing data
                        if not all([chain1, res1, chain2, res2]):
                            continue
                            
                        sel1 = f"#{chain1}:{res1}"
                        if atom1:
                            sel1 += f"@{atom1}"
                            
                        sel2 = f"#{chain2}:{res2}"
                        if atom2:
                            sel2 += f"@{atom2}"
                    
                    else:
                        # Generic handling for other interaction types
                        chain1 = interaction.get('chain1', interaction.get('residue1_chain'))
                        res1 = interaction.get('residue1', '').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                        
                        chain2 = interaction.get('chain2', interaction.get('residue2_chain'))
                        res2 = interaction.get('residue2', '').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                        
                        # Skip if missing data
                        if not all([chain1, res1, chain2, res2]):
                            continue
                            
                        sel1 = f"#{chain1}:{res1}"
                        sel2 = f"#{chain2}:{res2}"
                    
                    # Display the interacting residues as sticks
                    f.write(f"display {sel1},{sel2}\n")
                    f.write(f"show {sel1},{sel2}\n")
                    
                    # Add a distance monitor between them
                    f.write(f"distance {sel1} {sel2}\n")
                    
                except Exception as e:
                    logger.warning(f"Error processing interaction for Chimera: {e}")
                    continue
            
            # Set color for all distance monitors of this type
            f.write(f"color {color} pseudobonds\n\n")
        
        # Final settings
        f.write("# Final view settings\n")
        f.write("focus\n")
        f.write("set bg_color white\n")
        
        logger.info(f"Saved Chimera script to {output_file}")

def _export_vmd_script(self, output_file: str, pdb_file: str, 
                     interactions: Dict[str, List[Dict]]):
    """Generate VMD script (.tcl) to visualize interactions."""
    # Define colors for different interaction types (VMD RGB: 0-1 range)
    interaction_colors = {
        'hydrogen_bonds': '0.0 0.0 1.0',  # blue
        'ionic_interactions': '1.0 0.0 0.0',  # red
        'salt_bridges': '1.0 1.0 0.0',  # yellow
        'hydrophobic_interactions': '1.0 0.65 0.0',  # orange
        'pi_stacking': '0.5 0.0 0.5',  # purple
        'pi_cation': '0.0 0.5 0.0',  # green
        'disulfide': '0.85 0.65 0.13'  # gold
    }
    
    with open(output_file, 'w') as f:
        # Header
        f.write("# VMD script for visualizing protein interactions\n")
        f.write("# Generated by PandaProt\n\n")
        
        # Open the PDB file
        rel_path = os.path.relpath(pdb_file, os.path.dirname(output_file))
        f.write(f"mol new {rel_path}\n")
        
        # Initial display settings
        f.write("mol delrep 0 top\n")  # delete default representation
        f.write("mol representation NewCartoon\n")
        f.write("mol color ColorID 8\n")  # gray
        f.write("mol selection \"all\"\n")
        f.write("mol material Transparent\n")
        f.write("mol addrep top\n\n")
        
        # Setup graphics object for labels
        f.write("# Create a graphics object for labels\n")
        f.write("draw color black\n")
        f.write("draw materials off\n")
        
        # Handle each interaction type
        interaction_count = 0
        
        for interaction_type, interactions_list in interactions.items():
            if not interactions_list:
                continue
                
            color = interaction_colors.get(interaction_type, "0.5 0.5 0.5")  # default gray
            nice_name = interaction_type.replace('_', ' ').title()
            
            f.write(f"# {nice_name}\n")
            
            # Draw a legend item
            f.write(f"draw color {color}\n")
            f.write(f"draw text {{30 {interaction_count * 1.2 + 2} 0}} \"{nice_name}\"\n")
            interaction_count += 1
            
            for i, interaction in enumerate(interactions_list):
                try:
                    # Extract residue info based on interaction type
                    if interaction_type == 'hydrogen_bonds':
                        chain1 = interaction.get('donor_chain')
                        res1 = interaction.get('donor_residue').split()[-1] if ' ' in interaction.get('donor_residue', '') else interaction.get('donor_residue', '')
                        atom1 = interaction.get('donor_atom')
                        
                        chain2 = interaction.get('acceptor_chain')
                        res2 = interaction.get('acceptor_residue').split()[-1] if ' ' in interaction.get('acceptor_residue', '') else interaction.get('acceptor_residue', '')
                        atom2 = interaction.get('acceptor_atom')
                        
                        # Skip if missing data
                        if not all([chain1, res1, atom1, chain2, res2, atom2]):
                            continue
                            
                        sel1 = f"chain {chain1} and resid {res1} and name {atom1}"
                        sel2 = f"chain {chain2} and resid {res2} and name {atom2}"
                        
                    elif interaction_type in ['ionic_interactions', 'salt_bridges']:
                        if all(k in interaction for k in ['positive_residue', 'positive_chain']):
                            chain1 = interaction.get('positive_chain')
                            res1 = interaction.get('positive_residue').split()[-1] if ' ' in interaction.get('positive_residue', '') else interaction.get('positive_residue', '')
                            atom1 = interaction.get('positive_atom')
                            
                            chain2 = interaction.get('negative_chain')
                            res2 = interaction.get('negative_residue').split()[-1] if ' ' in interaction.get('negative_residue', '') else interaction.get('negative_residue', '')
                            atom2 = interaction.get('negative_atom')
                        else:
                            # Fallback to generic naming
                            chain1 = interaction.get('chain1')
                            res1 = interaction.get('residue1').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                            atom1 = interaction.get('atom1')
                            
                            chain2 = interaction.get('chain2')
                            res2 = interaction.get('residue2').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                            atom2 = interaction.get('atom2')
                            
                        # Skip if missing data
                        if not all([chain1, res1, chain2, res2]):
                            continue
                        
                        # Use all atoms if specific atoms not provided
                        if not atom1:
                            sel1 = f"chain {chain1} and resid {res1}"
                        else:
                            sel1 = f"chain {chain1} and resid {res1} and name {atom1}"
                            
                        if not atom2:
                            sel2 = f"chain {chain2} and resid {res2}"
                        else:
                            sel2 = f"chain {chain2} and resid {res2} and name {atom2}"
                    
                    else:
                        # Generic handling for other interaction types
                        chain1 = interaction.get('chain1', interaction.get('residue1_chain'))
                        res1 = interaction.get('residue1', '').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                        
                        chain2 = interaction.get('chain2', interaction.get('residue2_chain'))
                        res2 = interaction.get('residue2', '').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                        
                        # Skip if missing data
                        if not all([chain1, res1, chain2, res2]):
                            continue
                            
                        sel1 = f"chain {chain1} and resid {res1}"
                        sel2 = f"chain {chain2} and resid {res2}"
                    
                    # Show the interacting residues as sticks
                    f.write(f"# Show residues involved in interaction {i+1}\n")
                    f.write(f"mol representation Licorice 0.3 12.0 12.0\n")
                    f.write(f"mol color Element\n")
                    f.write(f"mol selection \"({sel1}) or ({sel2})\"\n")
                    f.write(f"mol material Opaque\n")
                    f.write(f"mol addrep top\n")
                    
                    # Create a dashed line for the interaction
                    f.write(f"set sel1 [atomselect top \"{sel1}\"]\n")
                    f.write(f"set sel2 [atomselect top \"{sel2}\"]\n")
                    f.write(f"set coord1 [lindex [$sel1 get {{{atom1 if atom1 else 'x y z'}}}] 0]\n")
                    f.write(f"set coord2 [lindex [$sel2 get {{{atom2 if atom2 else 'x y z'}}}] 0]\n")
                    f.write(f"draw color {color}\n")
                    f.write(f"draw line $coord1 $coord2 style dashed width 3\n")
                    f.write(f"$sel1 delete\n")
                    f.write(f"$sel2 delete\n\n")
                    
                except Exception as e:
                    logger.warning(f"Error processing interaction for VMD: {e}")
                    continue
        
        # Final view settings
        f.write("# Final view settings\n")
        f.write("color Display Background white\n")
        f.write("display projection Orthographic\n")
        f.write("display depthcue off\n")
        f.write("display nearclip set 0.01\n")
        f.write("axes location Off\n")
        f.write("stage location Off\n")
        f.write("display resize 800 800\n")
        f.write("display resetview\n")
        
        logger.info(f"Saved VMD script to {output_file}")

def _export_molstar_script(self, output_file: str, pdb_file: str, 
                         interactions: Dict[str, List[Dict]]):
    """Generate MolStar viewer HTML/JS file to visualize interactions."""
    # Define colors for different interaction types
    interaction_colors = {
        'hydrogen_bonds': '0x0000FF',  # blue
        'ionic_interactions': '0xFF0000',  # red
        'salt_bridges': '0xFFFF00',  # yellow
        'hydrophobic_interactions': '0xFFA500',  # orange
        'pi_stacking': '0x800080',  # purple
        'pi_cation': '0x008000',  # green
        'disulfide': '0xDAA520'  # gold
    }
    
    # Get PDB file base name
    pdb_basename = os.path.basename(pdb_file)
    
    # Collect all interactions in a format usable by Molstar
    molstar_interactions = []
    
    for interaction_type, interactions_list in interactions.items():
        if not interactions_list:
            continue
            
        color = interaction_colors.get(interaction_type, "0x808080")  # default gray
        
        for i, interaction in enumerate(interactions_list):
            try:
                # Extract residue info based on interaction type
                if interaction_type == 'hydrogen_bonds':
                    chain1 = interaction.get('donor_chain')
                    res1 = interaction.get('donor_residue').split()[-1] if ' ' in interaction.get('donor_residue', '') else interaction.get('donor_residue', '')
                    atom1 = interaction.get('donor_atom')
                    
                    chain2 = interaction.get('acceptor_chain')
                    res2 = interaction.get('acceptor_residue').split()[-1] if ' ' in interaction.get('acceptor_residue', '') else interaction.get('acceptor_residue', '')
                    atom2 = interaction.get('acceptor_atom')
                    
                    # Skip if missing data
                    if not all([chain1, res1, atom1, chain2, res2, atom2]):
                        continue
                        
                    locator1 = f"/chainID:{chain1}/auth_seq_id:{res1}/auth_atom_id:{atom1}"
                    locator2 = f"/chainID:{chain2}/auth_seq_id:{res2}/auth_atom_id:{atom2}"
                    
                elif interaction_type in ['ionic_interactions', 'salt_bridges']:
                    if all(k in interaction for k in ['positive_residue', 'positive_chain']):
                        chain1 = interaction.get('positive_chain')
                        res1 = interaction.get('positive_residue').split()[-1] if ' ' in interaction.get('positive_residue', '') else interaction.get('positive_residue', '')
                        atom1 = interaction.get('positive_atom')
                        
                        chain2 = interaction.get('negative_chain')
                        res2 = interaction.get('negative_residue').split()[-1] if ' ' in interaction.get('negative_residue', '') else interaction.get('negative_residue', '')
                        atom2 = interaction.get('negative_atom')
                    else:
                        # Fallback to generic naming
                        chain1 = interaction.get('chain1')
                        res1 = interaction.get('residue1').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                        atom1 = interaction.get('atom1')
                        
                        chain2 = interaction.get('chain2')
                        res2 = interaction.get('residue2').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                        atom2 = interaction.get('atom2')
                        
                    # Skip if missing data
                    if not all([chain1, res1, chain2, res2]):
                        continue
                    
                    # Use CA atoms if specific atoms not provided
                    if atom1:
                        locator1 = f"/chainID:{chain1}/auth_seq_id:{res1}/auth_atom_id:{atom1}"
                    else:
                        locator1 = f"/chainID:{chain1}/auth_seq_id:{res1}/auth_atom_id:CA"
                        
                    if atom2:
                        locator2 = f"/chainID:{chain2}/auth_seq_id:{res2}/auth_atom_id:{atom2}"
                    else:
                        locator2 = f"/chainID:{chain2}/auth_seq_id:{res2}/auth_atom_id:CA"
                
                else:
                    # Generic handling for other interaction types
                    chain1 = interaction.get('chain1', interaction.get('residue1_chain'))
                    res1 = interaction.get('residue1', '').split()[-1] if ' ' in interaction.get('residue1', '') else interaction.get('residue1', '')
                    
                    chain2 = interaction.get('chain2', interaction.get('residue2_chain'))
                    res2 = interaction.get('residue2', '').split()[-1] if ' ' in interaction.get('residue2', '') else interaction.get('residue2', '')
                    
                    # Skip if missing data
                    if not all([chain1, res1, chain2, res2]):
                        continue
                        
                    locator1 = f"/chainID:{chain1}/auth_seq_id:{res1}/auth_atom_id:CA"
                    locator2 = f"/chainID:{chain2}/auth_seq_id:{res2}/auth_atom_id:CA"
                
                # Add this interaction to the list
                molstar_interactions.append({
                    'type': interaction_type.replace('_', ' ').title(),
                    'color': color,
                    'locator1': locator1,
                    'locator2': locator2,
                    'label': f"{interaction_type.replace('_', ' ').title()} {chain1}:{res1} - {chain2}:{res2}"
                })
                
            except Exception as e:
                logger.warning(f"Error processing interaction for Molstar: {e}")
                continue
    
    # Write HTML with embedded JavaScript for Molstar
    with open(output_file, 'w') as f:
        # Write a complete HTML file with the Molstar viewer and our data
        f.write(f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <title>PandaProt - Protein Interactions in Molstar</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        html, body {{ width: 100%; height: 100%; }}
        #viewer {{ width: 100%; height: 100%; }}
        #legend {{ 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            background: rgba(255, 255, 255, 0.8); 
            padding: 10px; 
            border-radius: 5px;
            z-index: 1000;
        }}
        .legend-item {{ 
            display: flex; 
            align-items: center; 
            margin: 5px 0; 
        }}
        .color-box {{ 
            width: 15px; 
            height: 15px; 
            margin-right: 8px; 
            border: 1px solid #999; 
        }}
    </style>
    <script src="https://unpkg.com/molstar@3.30.0/lib/molstar.js"></script>
</head>
<body>
    <div id="viewer"></div>
    <div id="legend">
        <h3>Interaction Types</h3>
        <div id="legend-items"></div>
    </div>
    
    <script>
        // Initialize the Molstar viewer
        async function init() {{
            // Create viewer
            const viewer = new molstar.Viewer('viewer', {{
                layoutIsExpanded: false,
                layoutShowControls: false,
                layoutShowRemoteState: false,
                layoutShowSequence: true,
                layoutShowLog: false,
                layoutShowLeftPanel: false,
                volumeStreamingDisabled: true,
                viewportShowExpand: true,
                viewportShowSelectionMode: false,
                viewportShowAnimation: false,
                viewportShowTrackball: false,
                viewportShowSlices: false,
                viewportShowAxis: false,
                viewportShowFog: false
            }});
            
            // Load the PDB file
            const data = await viewer.loadPdb('{pdb_basename}', {{ 
                representationParams: {{ 
                    theme: {{ globalName: 'chain-id' }},
                    type: 'cartoon',
                    color: 'chain-id',
                    opacity: 0.7
                }}
            }});
            
            // Setup the shape component for interactions
            const shapeComp = await viewer.build().to(data.buildNode).apply(molstar.MeshBuilder.createShape()).commit();
            
            // Set initial camera position
            const camera = viewer.plugin.canvas3d?.camera;
            
            // Add each interaction
            const interactions = {str(molstar_interactions).replace("'", '"')};
            const interactionTypes = new Set(interactions.map(i => i.type));
            
            // Create legend
            const legendItems = document.getElementById('legend-items');
            const typesAndColors = Array.from(interactionTypes).map(type => {{
                const color = interactions.find(i => i.type === type).color;
                return {{ type, color }};
            }});
            
            // Sort and add legend items
            typesAndColors.sort((a, b) => a.type.localeCompare(b.type));
            typesAndColors.forEach(item => {{
                const div = document.createElement('div');
                div.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = '#' + item.color.substring(2);
                
                const label = document.createElement('span');
                label.textContent = item.type;
                
                div.appendChild(colorBox);
                div.appendChild(label);
                legendItems.appendChild(div);
            }});
            
            // Add interactions to the viewer
            for (const interaction of interactions) {{
                try {{
                    // Get atom positions
                    const lociA = data.selectLoci({{ label_entity: interaction.locator1 }});
                    const lociB = data.selectLoci({{ label_entity: interaction.locator2 }});
                    
                    if (!lociA || !lociB) continue;
                    
                    const posA = data.getLoci3DPosition(lociA);
                    const posB = data.getLoci3DPosition(lociB);
                    
                    if (!posA || !posB) continue;
                    
                    // Draw a cylinder between atoms
                    const builder = viewer.build().to(shapeComp);
                    builder.addCylinder(
                        {{ x: posA.x, y: posA.y, z: posA.z }}, 
                        {{ x: posB.x, y: posB.y, z: posB.z }}, 
                        {{ radius: 0.1, radiusTop: 0.1, color: interaction.color, dashed: true }}
                    );
                    
                    // Highlight the residues
                    const residueA = data.selectLoci({{ 
                        label_entity: interaction.locator1.substring(0, interaction.locator1.lastIndexOf('/')) 
                    }});
                    const residueB = data.selectLoci({{ 
                        label_entity: interaction.locator2.substring(0, interaction.locator2.lastIndexOf('/')) 
                    }});
                    
                    builder.addRepresentation('ball-and-stick', {{ 
                        theme: {{ globalName: 'element-symbol' }},
                        color: 'element-symbol',
                        loci: [residueA, residueB]
                    }});
                    
                    builder.commit();
                    
                    // Add a label
                    viewer.plugin.labels?.addLabel(interaction.label, {{ 
                        x: (posA.x + posB.x) / 2, 
                        y: (posA.y + posB.y) / 2, 
                        z: (posA.z + posB.z) / 2 
                    }});
                    
                }} catch (e) {{
                    console.error('Error adding interaction', e);
                }}
            }}
            
            // final settings
            viewer.plugin.canvas3d?.setBackground({{ color: 0xffffff }});
            viewer.plugin.canvas3d?.setDimension({{ x: 800, y: 800 }});
            
            // Focus view
            viewer.plugin.canvas3d?.requestCameraReset();
        }}
        
        // Call the init function when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>""")
    
    logger.info(f"Saved Molstar viewer to {output_file}")